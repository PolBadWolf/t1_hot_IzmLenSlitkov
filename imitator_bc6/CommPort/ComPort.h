//---------------------------------------------------------------------------

#ifndef ComPortH
#define ComPortH
#include <Classes.hpp>
//---------------------------------------------------------------------------

struct TvsMem
{
        unsigned char *UkMass;
        int            LenMass;
};
class TvMass
{
private:
        TvsMem *vsMem;
        int len;
        CRITICAL_SECTION csvm;
        int ind_wr;
        int ind_rd;
        int __fastcall adr(int adr);
public:
        __fastcall TvMass(int n);
        __fastcall ~TvMass();
        void __fastcall Push(unsigned char *buff, int lens);
        int  __fastcall ReadCurent(unsigned char **buff, int &lens);
        int  __fastcall BuffLevel();
        void __fastcall ReadNext();
};



class TComPortRd : public TThread
{
private:
        HANDLE ComPort;
protected:
        void __fastcall Execute();
        void __fastcall EventNewDateSynhr();
public:
        __fastcall TComPortRd(HANDLE rdComPort);
        void __fastcall (__closure *EventNewDate) (int RdByte);
        OVERLAPPED over;
        COMSTAT curstat;
        DWORD btr, temp1, temp2, mask, signal;
        int  __fastcall ReadBuf(unsigned char *Buf, DWORD *len_zakaz, DWORD *len_ok);
        bool work;
};


class TComPortWr : public TThread
{
private:
        HANDLE ComPort;
protected:
        void __fastcall Execute();
public:
        TvMass *Mass;
        __fastcall TComPortWr(HANDLE wrComPort);
        OVERLAPPED over;
        void __fastcall WriteBuff(unsigned char *Buf, DWORD len);
        bool work;
};


enum eBaudRate {
        BaudRate110    = CBR_110,
        BaudRate300    = CBR_300,
        BaudRate600    = CBR_600,
        BaudRate1200   = CBR_1200,
        BaudRate2400   = CBR_2400,
        BaudRate4800   = CBR_4800,
        BaudRate9600   = CBR_9600,
        BaudRate14400  = CBR_14400,
        BaudRate19200  = CBR_19200,
        BaudRate38400  = CBR_38400,
        BaudRate56000  = CBR_56000,
        BaudRate57600  = CBR_57600,
        BaudRate115200 = CBR_115200,
        BaudRate128000 = CBR_128000,
        BaudRate256000 = CBR_256000
};

enum eByteSize {
        ByteSize4 = 4,
        ByteSize5 = 5,
        ByteSize6 = 6,
        ByteSize7 = 7,
        ByteSize8 = 8
};

enum eParity {
        EVEN  = EVENPARITY,
        MARK  = MARKPARITY,
        NO    = NOPARITY,
        ODD   = ODDPARITY,
        SPACE = SPACEPARITY
};

enum eStopBits {
        StopBitsONE  = 0,
        StopBitsONE5 = 1,
        StopBitsTWO  = 2
};

enum eDTR_CONTROL {
        DTR_DISABLE   = DTR_CONTROL_DISABLE,
        DTR_ENABLE    = DTR_CONTROL_ENABLE,
        DTR_HANDSHAKE = DTR_CONTROL_HANDSHAKE
};

enum  eRTS_CONTROL {
        RTS_DISABLE   = RTS_CONTROL_DISABLE,
        RTS_ENABLE    = RTS_CONTROL_ENABLE,
        RTS_HANDSHAKE = RTS_CONTROL_HANDSHAKE,
        RTS_TOGGLE    = RTS_CONTROL_TOGGLE
};

class TComPort
{
private:
        TComPortRd      *NitRead;
        HANDLE          COMport;        
        TComPortWr      *NitWrite;
        // callback функция пришли новые данные
        void __fastcall fEventNewDate(int RdByte);
public:
        __fastcall TComPort();
        __fastcall ~TComPort();
        int  __fastcall Open(AnsiString PortName,
                             eBaudRate  BaudRate,
                             eParity    Parity);
        void  __fastcall Close();
        // **************************************************************************************************************
        // Включает режим слежения за сигналом CTS.
        // Если это поле равно TRUE и сигнал CTS сброшен, то передача данных приостанавливается до установки сигнала CTS.
        // Это позволяет подключённому к компьютеру прибору приостановить поток передаваемой в него информации,
        // если он не успевает ее обрабатывать.
        bool OutxCtsFlow; // = false;
        // **************************************************************************************************************
        // Включает режим слежения за сигналом DSR. Если это поле равно TRUE и сигнал DSR сброшен,
        // передача данных прекращается до установки сигнала DSR.
        bool OutxDsrFlow; // = false;
        // **************************************************************************************************************
        // Задает режим управления обменом для сигнала DTR. Это поле может принимать следующие значения:
        // DTR_CONTROL_DISABLE   - Запрещает использование линии DTR
        // DTR_CONTROL_ENABLE    - Разрешает использование линии DTR
        // DTR_CONTROL_HANDSHAKE - Разрешает использование рукопожатия для выхода из ошибочных ситуаций.
        //    Этот режим используется, в частности, модемами при восстановлении в ситуации потери связи.
        eDTR_CONTROL DTR_CONTROL; // = DTR_CONTROL_DISABLE;
        // **************************************************************************************************************
        // Задает чувствительсть коммуникационного драйвера к состоянию линии DSR.
        // Если это поле равно TRUE, то все принимаемые данные игнорируются драйвером
        // (коммуникационный драйвер расположен в операционной системе),
        // за исключением тех, которые принимаются при установленном сигнале DSR.
        bool DsrSensitivity; // = false;
        // **************************************************************************************************************
        // Задает, прекращается ли передача при переполнении приемного буфера и передаче драйвером символа XoffChar.
        // Если это поле равно TRUE, то передача продолжается, несмотря на то,
        // что приемный буфер содержит более XoffLim символов и близок к переполнению,
        // а драйвер передал символ XoffChar для приостановления потрока принимаемых данных.
        // Если поле равно FALSE, то передача не будет продолжена до тех пор,
        // пока в приемном буфере не останется меньше XonLim символов и драйвер не передаст
        // символ XonChar для возобновления потока принимаемых данных.
        // Таким образом это поле вводит некую зависимость между управлением входным и выходным потоками информации.
        bool TXContinueOnXoff; // = true;
        // **************************************************************************************************************
        // Задает использование XON/XOFF управления потоком при передаче.
        // Если это поле равно TRUE, то передача останавливается при приеме символа XoffChar,
        // и возобновляется при приеме символа XonChar.
        bool OutX; // = false;
        // **************************************************************************************************************
        // Задает использование XON/XOFF управления потоком при приеме. Если это поле равно TRUE,
        // то драйвер передает символ XoffChar, когда в приемном буфере находится более XoffLim,
        // и XonChar, когда в приемном буфере остается менее XonLim символов.
        bool InX; // = false;
        // **************************************************************************************************************
        // Указывает на необходимость замены символов с ошибкой четности на символ задаваемый полем ErrorChar.
        // Если это поле равно TRUE, и поле fParity равно TRUE, то выполняется замена.
        bool ErrorChar; // = false;
        // **************************************************************************************************************
        // Определяет действие выполняемое при приеме нулевого байта.
        // Если это поле TRUE, то нулевые байты отбрасываются при передаче.
        bool pNull; // = false;
        // **************************************************************************************************************
        // Задает режим управления потоком для сигнала RTS.
        // Если это поле равно 0, то по умолчанию подразумевается RTS_CONTROL_HANDSHAKE.
        // Поле может принимать одно из следующих значений:
        // RTS_CONTROL_DISABLE   - Запрещает использование линии RTS
        // RTS_CONTROL_ENABLE    - Разрешает использование линии RTS
        // RTS_CONTROL_HANDSHAKE - Разрешает использование RTS рукопожатия.
        //                         Драйвер устанавливает сигнал RTS когда приемный буфер заполнен менее,
        //                         чем на половину, и сбрасывает, когда буфер заполняется более чем на три четверти.
        // RTS_CONTROL_TOGGLE    - Задает, что сигнал RTS установлен, когда есть данные для передачи.
        //                         Когда все символы из передающего буфера переданы, сигнал сбрасывается.
        eRTS_CONTROL RTS_CONTROL;
        // **************************************************************************************************************
        // Задает игнорирование всех операций чтения/записи при возникновении ошибки.
        // Если это поле равно TRUE, драйвер прекращает все операции чтения/записи для порта при возникновении ошибки.
        // Продолжать работать с портом можно будет только после устранения причины ошибки и вызова функции ClearCommError.
        bool AbortOnError; // = false;
        // **************************************************************************************************************
        // Задает минимальное число символов в приемном буфере перед посылкой символа XON.
        int pXonLim; // = 2048;
        // **************************************************************************************************************
        // Определяет максимальное количество байт в приемном буфере перед посылкой символа XOFF.
        // Максимально допустимое количество байт в буфере вычисляется вычитанием данного значения
        // из размера применного буфера в байтах.
        int pXoffLim; // = 512;
        // **************************************************************************************************************
        // Определяет число информационных бит в передаваемых и принимаемых байтах.
        eByteSize  ByteSize; // 8
        // **************************************************************************************************************
        // Задает количество стоповых бит. Поле может принимать следующие значения:
        // ONESTOPBIT  - Один стоповый бит
        // ONE5STOPBIT - Полтора стоповых бита
        // TWOSTOPBIT  - Два стоповых бита
        eStopBits  StopBits; // 2
        // **************************************************************************************************************
        // Задает символ XON используемый как для приема, так и для передачи.
        char pXonChar; // = 17;
        // **************************************************************************************************************
        // Задает символ XOFF используемый как для приема, так и для передачи.
        char pXoffChar; // = 19;
        // **************************************************************************************************************
        // Задает символ, использующийся для замены символов с ошибочной четностью.
        char pErrorChar; // = 0;
        // **************************************************************************************************************
        // Задает символ, использующийся для сигнализации о конце данных.
        char pEofChar; // = 0;
        // **************************************************************************************************************
        // Задает символ, использующийся для сигнализации о событии.
        char pEvtChar; // = 0;
        // ===================
        void __fastcall (__closure *EventNewDate) (int RdByte);
        int  __fastcall ReadBuf(unsigned char *Buf, DWORD *len_zakaz, DWORD *len_ok);
        void __fastcall wr(unsigned char *Buf, DWORD len);
        int  __fastcall WriteBufferLevel();
};
#endif

